/*=========| REDACTED |=========*/

    Abilities.Init.cs:

        public interface ICooldownable {
            /// <summary>
            /// Return a float between 0-1 that returns percentage charged. return (cooldownTime - remainingCooldownTime) / cooldownTime;
            /// </summary>
            public float GetCooldownPercentage();
        }

    NetworkedEntity.cs:

        public void AbilityHealCalled() {
            StartCoroutine(AbilityHealCoroutine());
        }

        private IEnumerator AbilityHealCoroutine() {
            abilityHealOn = true;
            yield return new WaitForSeconds(2f);
            abilityHealOn = false;
        }

        ...
        Health = Mathf.Min(mainEntity.GetMaxHealth(),
				Health + Time.deltaTime * mainEntity.GetMaxHealth() / 5f);
		mainEntity.UpdateHealthBar();
        ...

        overclock ability:
        if (abilityOverclockOn) {
            PlayerInfo.instance.ReloadFaster();
            optionalCombatEntity.GetTurret().ReloadFaster();
        }
        //healing ability, TODO: scale by ability stats instead
        if (abilityHealOn) {
            Health = Mathf.Min(mainEntity.GetMaxHealth(),
                Health + Time.deltaTime * mainEntity.GetMaxHealth() / 5f);
            mainEntity.UpdateHealthBar();
        }

        public void AbilityOverclockCalled() {
            StartCoroutine(AbilityOverclockCoroutine());
        }

        private IEnumerator AbilityOverclockCoroutine() {
            abilityOverclockOn = true;
            yield return new WaitForSeconds(2f);
            abilityOverclockOn = false;
        }
    
    PlayerInfo.cs:

        public void AbilityHealActivated() {
            //rn just assume ability slot 0.
            abilities.PushAbilityActivation(0);
            //NetworkedEntity.playerInstance.AbilityHealCalled();
        }
        public void AbilityOverclockActivated() {
            NetworkedEntity.playerInstance.AbilityOverclockCalled();
        }